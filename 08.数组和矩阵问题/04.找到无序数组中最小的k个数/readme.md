# 找到无序数组中最小的k个数

【题目】给定一个无序数组arr，找到其中最小的k个数。

【难度】O(Nlogk) 虎 | O(Nlogk) 神

## 方案一
一直维护一个有k个数的大根堆，这个堆中存放的是目前选出的k个最小数，堆顶是k个数中最大的那个。遍历数组的过程中不断与堆顶比较，若比堆顶小，则将堆顶调整为当前元素，然后从堆顶调整整个堆。

## 方案二——使用BFPRT算法
*显而易见的是，如果我们找到了第k小的数，那么想求arr中最小的k个数，就是遍历一次数组的工作量而已。*
BFPRT算法的作用就是找到数组中第k小的数，假设其形式为`BFPRT(arr, k)`过程如下：
1. 将arr中的n个元素划分成n/5组，每组5个元素，最后不够5个也为一组(n%5个)。
2. 对每个组进行插入排序，只针对每个组最多5个元素之间的组内排序，组与组之间不排序。排序后找到每组的中位数，若组的元素个数为偶数，规定找下中位数。
3. 对于步骤2中找到的`n/5`个中位数，让这些中位数组成一个新的数组，即为`mArr`。递归调用`BFPRT(mArr, mArr.size() / 2)`，其意义是找到`mArr`数组中的中位数，即`mArr`中第`(mArr.size() / 2)`小的数。
4. 假设步骤3中递归调用`BFPRT(mArr, mArr.size() / 2)`后，返回的数为x。根据这个x划分整个数组(partition过程)，即：在arr中比x小的都在x左边，比x大的都在x右边。划分完成后，x在arr中的位置记为i。
5. 若`i+1==k`直接返回，

    * 若`i+1 < k`说明x位置在要找的数左边，应该在x的右边继续找，递归调用`BFPRT(arr[x+1:], k-i)`
    * 若`i+1 > k`说明x位置在要找的数左边，应该在x的左边继续找，递归调用`BFPRT(arr[:x], k)`



